/*
 * This source file was generated by the Gradle 'init' task
 */
package simple.lines;

import simple.lines.model.Point;
import simple.lines.model.Line;
import simple.lines.model.DrawingPanel;

import java.io.File;

import javax.swing.*;
import java.awt.*;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Stack;
import java.util.List;
import java.util.Map;
import java.util.AbstractMap;
import java.util.AbstractMap.SimpleEntry; // No pair in Java
import java.util.Set;
import java.util.Arrays;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class App {

    public static List<List<Point>> walkLineSegment(Point startPoint, HashMap<Point, ArrayList<Point>> adjacencyM, Set<Point> lineSegmentCandidates, Set<Point> visited) {
        List<List<Point>> segments = new ArrayList<>();
        Stack<Object[]> stack = new Stack<>();
        stack.push(new Object[]{startPoint, new ArrayList<>(Arrays.asList(startPoint))});

        while (!stack.isEmpty()) {
            Object[] currentPair = stack.pop();
            Point current = (Point) currentPair[0];
            List<Point> path = (List<Point>) currentPair[1];

            if (!visited.contains(current)) {
                visited.add(current);
                ArrayList<Point> neighbors = adjacencyM.get(current);

                for (Point neighbor : neighbors) {
                    if (visited.contains(neighbor)) {
                        continue;
                    }
                    List<Point> newPath = new ArrayList<>(path);
                    newPath.add(neighbor);

                    if (lineSegmentCandidates.contains(neighbor)) {
                        segments.add(newPath);
                    } else if (adjacencyM.get(neighbor).size() == 2) {
                        stack.push(new Object[]{neighbor, newPath});
                    } else {
                        segments.add(newPath);
                    }
                }
            }
        }
        return segments;
    }

    public static void main(String[] args) {

        // TODO: Read file
        // TODO: Combine lines whenever their end/start points correspond, but only with a single other line
        // TODO: Draw lines in different colors, print their length in decending order 

        // Approach: build adjacency list
        HashSet<Point> vertices = new HashSet<>();
        ArrayList<Line> edges = new ArrayList<>();

        // Adjacency list
        HashMap<Point, ArrayList<Point>> adjList = new HashMap<>();

        // 1. Read file
        BufferedReader reader;
        try {
			reader = new BufferedReader(new FileReader(new File("src/main/resources/input.txt")));
            String line;

            while ((line = reader.readLine())!= null) {
                String[] split = line.split(" ");
                Point p1 = new Point(Float.parseFloat(split[0]), Float.parseFloat(split[1]));
                Point p2 = new Point(Float.parseFloat(split[2]), Float.parseFloat(split[3]));
                vertices.add(p1);
                vertices.add(p2);
                edges.add(new Line(p1, p2));
			}

			reader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

        // Initialize adjacency list
        for (Point p : vertices) {
            adjList.put(p, new ArrayList<>());
        }

        // Fill adjacency list
        for (Line l : edges) {
            adjList.get(l.getStart()).add(l.getEnd());
            adjList.get(l.getEnd()).add(l.getStart());
        }

        // Which points will probably start linesegment
        Set<Point> lineSegmentCandidates = new HashSet<>();
        adjList.forEach((k, v) -> {
            if (v.size() == 1) lineSegmentCandidates.add(k);
            if (v.size() > 2) lineSegmentCandidates.add(k);
        });

        // Initialize lineSegments and visited
        List<List<Point>> lineSegments = new ArrayList<>();
        Set<Point> visited = new HashSet<>();


        for (Point startPoint : lineSegmentCandidates) {
            if (!visited.contains(startPoint)) {
                List<List<Point>> segments = walkLineSegment(startPoint, adjList, lineSegmentCandidates, visited);
                lineSegments.addAll(segments);
            }
        }


        // TODO: Segments of size 2 are no 'segments'... I should filter this within the algorithm
        List<List<Point>> reworkedLineSegments = new ArrayList<>();
        for (List<Point> segment : lineSegments) {
            if (segment.size() < 3) {
                continue;
            }
            reworkedLineSegments.add(segment);
        }


        List<Map.Entry<List<Point>, Double>> segmentLengths = new ArrayList<>();
        for (List<Point> segment : reworkedLineSegments) {
            double sum = 0;
            for (int i = 0; i < segment.size() - 1; i++) {
                sum += new Line(segment.get(i), segment.get(i + 1)).getLength();
            }
            segmentLengths.add(new AbstractMap.SimpleEntry<>(segment, sum));
        }

        // Step 2: Sort the segments based on length in descending order
        segmentLengths.sort((a, b) -> Double.compare(b.getValue(), a.getValue()));

        // Step 3: Print the sorted segments
        for (Map.Entry<List<Point>, Double> entry : segmentLengths) {
            System.out.println("Segment: " + entry.getKey() + ", Length: " + entry.getValue());
        }

                // Step 4: Draw the segments
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Line Segments");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(1024, 1024);
            frame.add(new DrawingPanel(reworkedLineSegments));
            frame.setVisible(true);
        });

    }
}
